// -*- Mode: C++ -*-
// vim:ft=cpp
/**
 * (c) 2023 Max Kurze <max.kurze@mailbox.tu-dresden.de>
 *
 * This file is distributed under the terms of the
 * GNU General Public License 2.
 * Please see the LICENSE.md file for details.
 */
/**
 * @file
 * This library provides some logging utilities.
 *
 * @headerfile {l4/liblog/log}
 */
// TODO handle loggable_exception #ifdef __EXCEPTIONS

#pragma once

#include <chrono>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <stdexcept>
#include <string>
#include <thread>
#include <tuple>

#include <l4/fmt/chrono.h> // formatting of std::chrono
#include <l4/fmt/core.h>
#include <l4/fmt/std.h> // formatting of std::thread::id

// #include <l4/cxx/exceptions>
// #include <l4/liblog/loggable-exception>
#include <l4/re/env>
// #include <l4/re/error_helper>
// #include <l4/sys/err.h>
#include <l4/sys/semaphore>

namespace L4Re
{

namespace LibLog
{
/**
 * @brief The output level of the Log
 *
 * This level will control which log messages are written
 * to the ouput and which will silently return.
 *
 * @note the default Level will be INFO
 *
 * @note the level will only be saved inside the environment variable
 *       'LOG_LEVEL'
 *
 * A level will by default also activate all higher levels.
 * the versions prefixed with _ONLY can be used to construct
 * a specific combination.
 *
 * For example:
 * @code{.cpp}
 * L4Re::LibLog::setLevel(L4Re::LibLog::Level::WARN);
 * // all messages with warn or higher
 * // -> warn, error, fatal
 *
 * L4Re::LibLog::setLevel(L4Re::LibLog::Level::DEBUG_ONLY |
 *   L4Re::LibLog::Level::ERROR_ONLY);
 * // only debug and error messages.
 * @endcode
 */
// class Level
// {
// public:
//   // clang-format off
//   enum : l4_uint8_t
//   {
//     DEBUG =      0b11111,
//     INFO  =      0b01111,
//     WARN  =      0b00111,
//     ERROR =      0b00011,
//     FATAL =      0b00001,

//     DEBUG_ONLY = 0b10000,
//     INFO_ONLY  = 0b01000,
//     WARN_ONLY  = 0b00100,
//     ERROR_ONLY = 0b00010,
//     FATAL_ONLY = 0b00001,
//   };
//   // clang-format on
// };

// /**
//  * @brief Set the output level of the log
//  */
// inline static void
// setLevel (l4_uint8_t lvl)
// {
//   setenv ("LOG_LEVEL", std::to_string (lvl).c_str (), true);
// }

// /**
//  * @brief Get the output log level
//  */
// inline static l4_uint8_t
// getLevel ()
// {
//   char *lvl = getenv ("LOG_LEVEL");
//   // clang-format off
//     if (lvl)
// #ifdef __EXCEPTIONS
//       try { return std::stoi (lvl); }
//       catch (std::invalid_argument &) {}
// #else
//       return atoi(lvl);
// #endif
//   // clang-format on
//   return Level::INFO;
// }

/**
 * @brief The level of a specific Log message.
 *
 * The level should always have exactly one set bit.
 *
 * This enum will be used implicitly by the level-named
 * functions e.g. error, debug, etc.
 *
 */
// clang-format off
// enum MsgLevel : l4_uint8_t
// {
//   DEBUG = 0b10000,
//   INFO  = 0b01000,
//   WARN  = 0b00100,
//   ERROR = 0b00010,
//   FATAL = 0b00001,
// };
// clang-format on

// clang-format off
struct DEBUG { static constexpr const char *name = "\033[34;1mDEBUG\033[0m"; };
struct INFO  { static constexpr const char *name = "\033[36;1mINFO \033[0m"; };
struct WARN  { static constexpr const char *name = "\033[33;1mWARN \033[0m"; };
struct ERROR { static constexpr const char *name = "\033[31;1mERROR\033[0m"; };
struct FATAL { static constexpr const char *name = "\033[35;1mFATAL\033[0m"; };
// clang-format on

struct NoSync
{
  void
  start ()
  {
  }
  void
  end ()
  {
  }
};

template <const char *sem_cap_name> struct SemaphoreSync
{
  L4::Cap<L4::Semaphore> sema = Env::env () -> get_cap<L4::Semaphore> (sem_cap_name);
  l4_umword_t store;

  void
  start ()
  {
    store = l4_utcb_mr ()->mr[0]; // sema->down will change the first mr
    if (sema.is_valid ())
      sema->down ();
  }
  void
  end ()
  {
    if (sema.is_valid ())
      sema->up ();
    l4_utcb_mr ()->mr[0] = store;
  }
};

template <typename Severity> struct NoSilence
{
  static constexpr bool
  silence ()
  {
    return false;
  };
};

struct VerboseFormat
{
  static constexpr const char *format = "\033[2m{thread_id:>10} {time:%T}\033[0m {severity:s} {pkgname:s} \033[2m<{file:s}:{line:d}> {function:s}\033[0m {msg:s}\n";
};

struct CleanFormat
{
  static constexpr const char *format = "\033[2m{time:%S}\033[0m {severity:s} {pkgname:s} {msg:s}\n";
};


/**
 * A class to pass a format string while capturing the source location of the
 * invocation
 *
 * This workaround is necessary since it is not possible to pass the location
 * as default arguments while allowing a variable number of arguments for the
 * printing
 */
class Format
{
public:
  const char *format;
  const char *file;
  const char *function;
  const int line;

  Format (const char *format, const char *file = __builtin_FILE (),
          const char *function = __builtin_FUNCTION (),
          const int line = __builtin_LINE ())
      : format (format), file (file), function (function), line (line)
  {
  }
};

/**
 * @brief Generalized print method
 *
 * This method will do the actual printing.
 * Note: This method will print a line break per default!
 *
 * @param msg_lvl   The level of the message.
 * @param file      The file of the caller. Generated with __builtin_FILE
 * @param function  The function name of the caller. Generated with
 *                  __builtin_FUNCTION
 * @param line      The line index of the caller. Generated with
 *                  __builtin_LINE
 * @param fmt       A format string.
 * @param args      The arguments for the format string.
 */
template <typename Severity,
          template <typename> typename Silencer = NoSilence,
          typename Synchronizer = NoSync, 
          typename FormatSpecifier = CleanFormat,
          typename... Args>
inline static void
log (Format format, Args &&...args)
{
  /* check if message should be silenced */
  if (Silencer<Severity>::silence ())
    return;

  auto now = std::chrono::time_point_cast<std::chrono::microseconds>(std::chrono::high_resolution_clock::now ());
  auto t_id = std::this_thread::get_id ();

  // necessary for the ""_a literals for named format args
  using namespace fmt::literals;
  
  // clang-format off
  std::string out_string = fmt::format (
      FormatSpecifier::format,
      "thread_id"_a = t_id,
      "time"_a = now,
      "severity"_a = Severity::name,
      "pkgname"_a = getenv ("PKGNAME") ?: "",
      "file"_a = format.file + std::string (format.file).find_last_of('/') + 1,
      "line"_a = format.line,
      "function"_a = format.function,
      "msg"_a = fmt::format(format.format, args...));
  // clang-format on
  // TODO use strrchr instead of find last

  /**
   * Call print only once with the whole string.
   *
   * This will at least try to print string with a single ipc call to prevent
   * multiple concurrently running threads from interleaving their messages.
   */
  Synchronizer sync;
  sync.start ();

  L4Re::Env::env ()->log ()->print (out_string.c_str ());

  sync.end ();
};

}

}