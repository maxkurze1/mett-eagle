// -*- Mode: C++ -*-
// vim:ft=cpp
/**
 * (c) 2023 Max Kurze <max.kurze@mailbox.tu-dresden.de>
 *
 * This file is distributed under the terms of the
 * GNU General Public License 2.
 * Please see the COPYING-GPL-2 file for details.
 */
/**
 * @file
 * This library provides some logging utilities.
 *
 * @headerfile {l4/liblog/log}
 */

#pragma once

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <stdexcept>
#include <string>

#include <l4/cxx/exceptions>
#include <l4/liblog/loggable-exception>
#include <l4/re/env>

namespace L4Re
{

namespace LibLog
{

/**
 * @brief A utility class for a nice formatted log output
 */
class L4_EXPORT Log
{
public:
  /**
   * @brief The output level of the Log
   *
   * This level will control which log messages are written
   * to the ouput and which will silently return.
   *
   * @note the default Level will be INFO
   *
   * @note the level will only be saved inside the environment variable
   *       'LOG_LEVEL'
   *
   * A level will by default also activate all higher levels.
   * the versions prefixed with _ONLY can be used to construct
   * a specific combination.
   *
   * For example:
   * @code{.cpp}
   * L4Re::LibLog::setLevel(L4Re::LibLog::Level::WARN);
   * // all messages with warn or higher
   * // -> warn, error, fatal
   *
   * L4Re::LibLog::setLevel(L4Re::LibLog::Level::DEBUG_ONLY |
   *   L4Re::LibLog::Level::ERROR_ONLY);
   * // only debug and error messages.
   * @endcode
   */
  class Level
  {
  public:
    // clang-format off
    enum : l4_uint8_t
    {
      DEBUG =      0b11111,
      INFO  =      0b01111,
      WARN  =      0b00111,
      ERROR =      0b00011,
      FATAL =      0b00001,

      DEBUG_ONLY = 0b10000,
      INFO_ONLY  = 0b01000,
      WARN_ONLY  = 0b00100,
      ERROR_ONLY = 0b00010,
      FATAL_ONLY = 0b00001,
    };
    // clang-format on
  };

  /**
   * @brief Set the output level of the log
   */
  inline static void
  setLevel (l4_uint8_t lvl)
  {
    setenv ("LOG_LEVEL", std::to_string (lvl).c_str (), true);
  }

  /**
   * @brief Get the output log level
   */
  inline static l4_uint8_t
  getLevel ()
  {
    char *lvl = getenv ("LOG_LEVEL");
    // clang-format off
    if (lvl)
      try { return std::stoi (lvl); }
      catch (std::invalid_argument &) {}
    // clang-format on
    return Level::INFO;
  }

  /**
   * @brief The level of a specific Log message.
   *
   * The level should always have exactly one set bit.
   *
   * This enum will be used implicitly by the level-named
   * functions e.g. error, debug, etc.
   *
   */
  // clang-format off
  enum MsgLevel : l4_uint8_t
  {
    DEBUG = 0b10000,
    INFO  = 0b01000,
    WARN  = 0b00100,
    ERROR = 0b00010,
    FATAL = 0b00001,
  };
  // clang-format on

  /**
   * The print function is wrapped into a struct. This makes it possible to use
   * default parameters together with variadic arguments on it. This works
   * because the number and type of the variadic arguments are already known at
   * the creation of the struct and not deduced by the actual function call.
   *
   * To specify the template parameter of the struct the C++17 feature -
   * deduction guides and class template argument deduction (CTAD) - is used
   *
   * https://en.cppreference.com/w/cpp/language/class_template_argument_deduction
   */

  // ==================== DEBUG ====================
  template <typename... Args> struct debug
  {
    /**
     * @brief Write a debug message to the log
     * @note This method will print a line break per default!
     *
     * @param args  A c-style format string and arguments
     *
     * e.g.
     * @code{.cpp}
     * #include <l4/liblog/log>
     * L4Re::LibLog::Log::debug("some debug %s", "message");
     * @endcode
     */
    explicit debug (Args... args, char const *const file = __builtin_FILE (),
                    char const *const function = __builtin_FUNCTION (),
                    const int line = __builtin_LINE ())
    {
      printf (MsgLevel::DEBUG, file, function, line, args...);
    }
  };

  // User-defined deduction guide
  template <typename... Args> explicit debug (Args... args) -> debug<Args...>;

  // ==================== INFO  ====================
  template <typename... Args> struct info
  {
    /**
     * @brief Write an info message to the log
     * @note This method will print a line break per default!
     *
     * @param args  A c-style format string and arguments
     *
     * e.g.
     * @code{.cpp}
     * #include <l4/liblog/log>
     * L4Re::LibLog::Log::info("some info %s", "message");
     * @endcode
     */
    explicit info (Args... args, char const *const file = __builtin_FILE (),
                   char const *const function = __builtin_FUNCTION (),
                   const int line = __builtin_LINE ())
    {
      printf (MsgLevel::INFO, file, function, line, args...);
    }
  };

  // User-defined deduction guide
  template <typename... Args> explicit info (Args... args) -> info<Args...>;

  // ==================== WARN  ====================
  template <typename... Args> struct warn
  {
    /**
     * @brief Write a warn message to the log
     * @note This method will print a line break per default!
     *
     * @param args  A c-style format string and arguments
     *
     * e.g.
     * @code{.cpp}
     * #include <l4/liblog/log>
     * L4Re::LibLog::Log::warn("some warn %s", "message");
     * @endcode
     */
    explicit warn (Args... args, char const *const file = __builtin_FILE (),
                   char const *const function = __builtin_FUNCTION (),
                   const int line = __builtin_LINE ())
    {
      printf (MsgLevel::WARN, file, function, line, args...);
    }
  };

  // User-defined deduction guide
  template <typename... Args> explicit warn (Args... args) -> warn<Args...>;

  // ==================== ERROR ====================
  template <typename... Args> struct error
  {
    /**
     * @brief Write an error message to the log
     * @note This method will print a line break per default!
     *
     * @param args  A c-style format string and arguments
     *
     * e.g.
     * @code{.cpp}
     * #include <l4/liblog/log>
     * L4Re::LibLog::Log::error("some error %s", "message");
     * @endcode
     */
    explicit error (Args... args, char const *const file = __builtin_FILE (),
                    char const *const function = __builtin_FUNCTION (),
                    const int line = __builtin_LINE ())
    {
      printf (MsgLevel::ERROR, file, function, line, args...);
    }
  };

  // User-defined deduction guide
  template <typename... Args> explicit error (Args... args) -> error<Args...>;

  // ==================== FATAL ====================
  template <typename... Args> struct fatal
  {
    /**
     * @brief  Write a fatal message to the log
     * @note   This method will print a line break per default!
     *
     * @param args  A c-style format string and arguments
     *
     * e.g.
     * @code{.cpp}
     * #include <l4/liblog/log>
     * L4Re::LibLog::Log::fatal("some fatal %s", "message");
     * @endcode
     */
    explicit fatal (Args... args, char const *const file = __builtin_FILE (),
                    char const *const function = __builtin_FUNCTION (),
                    const int line = __builtin_LINE ())
    {
      printf (MsgLevel::FATAL, file, function, line, args...);
    }
  };

  // User-defined deduction guide
  template <typename... Args> explicit fatal (Args... args) -> fatal<Args...>;

  /**
   * @brief Generalized print method
   *
   * This method will do the actual printing.
   * Note: This method will print a line break per default!
   *
   * @param msg_lvl   The level of the message.
   * @param file      The file of the caller. Generated with __builtin_FILE
   * @param function  The function name of the caller. Generated with
   *                  __builtin_FUNCTION
   * @param line      The line index of the caller. Generated with
   *                  __builtin_LINE
   * @param fmt       A format string.
   * @param args      The arguments for the format string.
   *
   * Even if args is a variadic argument template the function it still needs
   * to be defined in a header file, just like normal templates.
   */
  template <typename... Args>
  inline static void
  printf (MsgLevel msg_lvl, char const *const file, char const *const function,
          const int line, char const *const fmt, Args... args)
  {
#ifndef NDEBUG
    /* check if message should be silenced */
    if (!(msg_lvl & getLevel ()))
      return;

    /* output current time and date */
    char *time = time_str ();
    /* output the Level prefix */
    const char *severity = severity_str (msg_lvl);
    /* output the package name */
    const char *pkgname = pkgname_str ();

    char *msg;
    asprintf (&msg, fmt, args...);
    /* print file name */
    char *string;
    asprintf (&string, "%s %s %s \033[2m<%s:%d> %s:\033[0m %s\n", time,
              severity, pkgname, rindex (file, '/') + 1, line, function, msg);

    /**
     * Call print only once with the whole string.
     *
     * This will at least try to print string with a single ipc call to prevent
     * multiple concurrently running threads from interleaving their messages.
     */
    L4Re::Env::env ()->log ()->print (string);

    free (string);
    free (msg);
    free (time);
#endif
  }

  /**
   * @brief Helper method to log Exceptions
   *
   * This method will be called when there is only an exception
   * given to the log function.
   *
   * Example:
   * @code{.cpp}
   * try
   *   {
   *    // anything ...
   *   }
   *  catch (L4::Base_exception &exc)
   *   {
   *     L4Re::LibLog::Log::fatal {exc};
   *   }
   * @endcode
   *
   * All argument are just passed to the general Log::printf
   */
  inline static void
  printf (MsgLevel msg_lvl, char const *const file, char const *const function,
          const int line, L4::Base_exception &exception)
  {
    printf (msg_lvl, file, function, line, "%s", exception.str ());
  }

  /**
   * @brief Helper method to log Runtime_error
   *
   * This method will be called for Runtime_errors in contrast to the
   * Base_exception logger it will also print the "extra_str" of the
   * given error.
   *
   * Example:
   * @code{.cpp}
   * try
   *   {
   *    // anything ...
   *   }
   * catch (L4::Runtime_error &exc)
   *   {
   *     L4Re::LibLog::Log::fatal {exc};
   *   }
   * @endcode
   */
  inline static void
  printf (MsgLevel msg_lvl, char const *const file, char const *const function,
          const int line, L4::Runtime_error &exception)
  {
    printf (msg_lvl, file, function, line, "%s: %s", exception.str (),
            exception.extra_str ());
  }

  /**
   * @brief Helper method to log Loggable_exceptions
   *
   * This method will be called for a Loggable_base_exception.
   * It will print the message of the error together with the location where
   * the error was thrown. (For all other error types only the location of
   * the printing statement will be logged)
   *
   * Example:
   * @code{.cpp}
   * try
   *   {
   *    // anything ...
   *   }
   * catch (L4Re::LibLog::Loggable_base_exception &exc)
   *   {
   *     L4Re::LibLog::Log::fatal {exc};
   *   }
   * @endcode
   */
  inline static void
  printf (MsgLevel msg_lvl, char const *const file, char const *const function,
          const int line, Loggable_base_exception &exc)
  {
    /* location of print statement is discarded */
    (void)file;
    (void)function;
    (void)line;
    printf (msg_lvl, exc.file (), exc.function (), exc.line (), "%s: %s",
            exc.str (), exc.msg ());
  }

private:
  /**
   * @brief Print the level prefix
   *
   * The prefix indicates which level the message
   * has.
   *
   * @param msg_lvl The level of the message
   * @param output The FILE* to write to
   *
   * @return The number of characters printed or a negative value if an output
   * error occurred.
   */
  static const char *
  severity_str (MsgLevel msg_lvl)
  {
    // clang-format off
    switch (msg_lvl)
      {
      case MsgLevel::DEBUG: return "\033[34;1mDEBUG\033[0m";
      case MsgLevel::INFO:  return "\033[36;1mINFO \033[0m";
      case MsgLevel::WARN:  return "\033[33;1mWARN \033[0m";
      case MsgLevel::ERROR: return "\033[31;1mERROR\033[0m";
      case MsgLevel::FATAL: return "\033[35;1mFATAL\033[0m";
      }
    // clang-format on
    return nullptr;
  }

  /**
   * @brief Print a prefix showing the time of the message
   *
   * Print the current timestamp into the log
   *
   * @param output The FILE* to write to
   *
   * @return The number of characters printed or a negative value if an output
   * error occurred.
   */
  static char *
  time_str ()
  {

    struct timespec ts;
    if (clock_gettime (CLOCK_REALTIME, &ts))
      return nullptr;

    // print sec : usec per default
    char *str;
    if (asprintf (&str, "%02ld:%03ld", ts.tv_sec, ts.tv_nsec / 1000000) == -1)
      return nullptr;
    return str;
  }

  /**
   * @brief Print a prefix with the name of the package
   *
   * The name of the package will be loaded from the PKGNAME
   * environment variable.
   *
   * @return The number of characters printed or a negative value if an output
   * error occurred.
   * @return -L4_ENOENT if PKGNAME was not set
   */
  static char *
  pkgname_str ()
  {
    return getenv ("PKGNAME");
  }
};

}

}