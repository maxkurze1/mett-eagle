From c0d9f2f154ebd374b47d05df753673ddc7735f29 Mon Sep 17 00:00:00 2001
From: Samxamnom <xamsamnam@gmail.com>
Date: Fri, 1 Sep 2023 21:14:55 +0200
Subject: [PATCH 1/1] thread-safe cap alloc

Change-Id: I83ba78c9bd18f9c8af16b7cdd88699271a8b6c27
---
 l4re/util/include/cap_alloc          |  4 +++-
 l4re/util/libs/cap_alloc.cc          |  7 +++++--
 l4sys/include/cxx/ipc_string         |  1 +
 ned/server/src/lua_exec.cc           |  2 +-
 uclibc/lib/libpthread/src/manager.cc | 10 ++++++++--
 5 files changed, 18 insertions(+), 6 deletions(-)

diff --git a/l4re/util/include/cap_alloc b/l4re/util/include/cap_alloc
index 0c45361e..231a1427 100644
--- a/l4re/util/include/cap_alloc
+++ b/l4re/util/include/cap_alloc
@@ -29,6 +29,7 @@
 #include <l4/sys/smart_capability>
 #include <l4/sys/task>
 #include <l4/re/consts>
+#include <l4/liballoc/alloc>
 
 namespace L4Re { namespace Util {
 
@@ -50,7 +51,8 @@ namespace L4Re { namespace Util {
  *
  * \note This capability allocator is not thread-safe.
  */
-extern _Cap_alloc &cap_alloc;
+// extern _Cap_alloc &cap_alloc;
+extern Alloc::Safe_counting_cap_alloc<> &cap_alloc;
 
 /**
  * Helper for Unique_cap and Unique_del_cap.
diff --git a/l4re/util/libs/cap_alloc.cc b/l4re/util/libs/cap_alloc.cc
index fb8e19a6..2261ae80 100644
--- a/l4re/util/libs/cap_alloc.cc
+++ b/l4re/util/libs/cap_alloc.cc
@@ -40,6 +40,7 @@ L4Re::Cap_alloc_t<L4Re::Util::Cap_alloc<4096> >
 
 #include <l4/re/dataspace>
 #include <l4/re/mem_alloc>
+#include <l4/liballoc/alloc>
 
 namespace
 {
@@ -62,14 +63,16 @@ namespace
     }
   };
 
-  Ca __attribute__((init_priority(INIT_PRIO_L4RE_UTIL_CAP_ALLOC))) __cap_alloc;
+  // Ca __attribute__((init_priority(INIT_PRIO_L4RE_UTIL_CAP_ALLOC))) __cap_alloc;
+    L4Re::Alloc::Safe_counting_cap_alloc<> __attribute__((init_priority(INIT_PRIO_L4RE_UTIL_CAP_ALLOC))) __cap_alloc;
 }
 
 #endif
 
 namespace L4Re {
   namespace Util {
-    _Cap_alloc &cap_alloc = __cap_alloc;
+    // _Cap_alloc &cap_alloc = __cap_alloc;
+    Alloc::Safe_counting_cap_alloc<> &cap_alloc = __cap_alloc;
   }
 #ifndef SHARED
   Cap_alloc *virt_cap_alloc = &__cap_alloc;
diff --git a/l4sys/include/cxx/ipc_string b/l4sys/include/cxx/ipc_string
index a06eb646..468c4770 100644
--- a/l4sys/include/cxx/ipc_string
+++ b/l4sys/include/cxx/ipc_string
@@ -26,6 +26,7 @@ namespace L4 { namespace Ipc {
 template<typename CHAR = char const, typename LEN = unsigned long>
 struct String : Array<CHAR, LEN>
 {
+  /** returns the number of characters excluding the '0' terminator */
   static LEN strlength(CHAR *d) { LEN l = 0; while (d[l]) ++l; return l; }
   String() {}
   String(CHAR *d) : Array<CHAR, LEN>(strlength(d) + 1, d) {}
diff --git a/ned/server/src/lua_exec.cc b/ned/server/src/lua_exec.cc
index 0c620029..d7d224ac 100644
--- a/ned/server/src/lua_exec.cc
+++ b/ned/server/src/lua_exec.cc
@@ -26,7 +26,7 @@
 
 using L4Re::chksys;
 
-inline void *operator new (size_t, void *p) noexcept { return p; }
+// inline void *operator new (size_t, void *p) noexcept { return p; }
 namespace Lua { namespace {
 
 class Lua_app_task : public App_task
diff --git a/uclibc/lib/libpthread/src/manager.cc b/uclibc/lib/libpthread/src/manager.cc
index ee09cdf1..0dda1a4e 100644
--- a/uclibc/lib/libpthread/src/manager.cc
+++ b/uclibc/lib/libpthread/src/manager.cc
@@ -536,11 +536,17 @@ int __pthread_mgr_create_thread(pthread_descr thread, char **tos,
   Env const *e = Env::env();
   auto _t = L4Re::Util::make_unique_cap<L4::Thread>();
   if (!_t.is_valid())
-    return -ENOMEM;
+   {
+     fprintf(stderr, "_t valid=%d\n", _t.is_valid());
+     return -ENOMEM;
+   }
 
   auto th_sem = L4Re::Util::make_unique_cap<Th_sem_cap>();
   if (!th_sem.is_valid())
-    return -ENOMEM;
+   {
+     fprintf(stderr, "th_sem valid=%d\n", th_sem.is_valid());
+     return -ENOMEM;
+   }
 
   int err = l4_error(e->factory()->create(_t.get()));
   if (err < 0)
-- 
2.41.0

